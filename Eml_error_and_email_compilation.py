# The following code was generated by ChatGPT Dec 15 Version (found at https://chat.openai.com/chat)
# ChatGPT gave the following explanation of the code:
#   This code defines a function extract_info() that takes a file path and returns the relevant information 
#   from the .eml file at that path. It then iterates over the .eml files in the specified folder and calls the 
#   extract_info() function on each file. The extracted information is added to the info_dict dictionary, where 
#   the keys are the email addresses and the values are dictionaries containing the error message, subject line, 
#   and whether the email is an automatic reply.

import email
import re
import json
import os 
from os import path # MINE
from collections import Counter

# Making this global. Will Probably move this to a config folder later.
emailRegEx = re.compile("[a-zA-Z0-9_\.\-\+]{1,}@[a-zA-Z0-9\-]+\.[a-zA-Z0-9]{2,4}") # using re.compile is faster if using the pattern repeatedly.

# Define a function to extract the relevant information from a .eml file
def extract_info(file_path):
    with open(file_path, 'r') as fileContents:
        msg = email.message_from_file(fileContents)

        xtractedFlds = {}
        xtractedFlds['Delivered-To']= msg['Delivered-To']
        xtractedFlds['Subject']= msg['Subject']
        xtractedFlds['Thread-Topic']= msg['Thread-Topic']
        xtractedFlds['X-Failed-Recipients']= msg['X-Failed-Recipients']
        xtractedFlds['Original-Recipient']= msg['Original-Recipient']
        xtractedFlds['Final-Recipient']= msg['Final-Recipient']
        xtractedFlds['From']= msg['From']
        xtractedFlds['To']= msg['To']
        xtractedFlds['Auto-Submitted']= msg['Auto-Submitted']
        xtractedFlds['X-Ham-Report']= msg['X-Ham-Report']
        # xtractedFlds['X-Ham-Report']= re.findall(emailRegEx, str(msg['X-Ham-Report']))
        
        # Used for filtering out invalid results
        clientAddr = xtractedFlds['Delivered-To']
        exclude_these = [clientAddr] # Can be an array of things to remove

        for part in msg.walk():
            for key in xtractedFlds.keys():
                if xtractedFlds[key] is None:
                    # To avoid setting the val of a key to that of the client's email addr
                    if clientAddr not in str(part[key]): 
                        xtractedFlds[key] = part[key]
            if part.get_content_type() == "text/plain":
                body = part.get_payload(decode=True)
                # Body has been extracted
                body_decoded = body.decode()
                # Extract all valid emails from body
                body_emails = re.findall(emailRegEx, body_decoded)
        # print(xtractedFlds['X-Ham-Report']) # WORKS
        # print(re.findall(r'[\w\.-]+@[\w\.-]+', str(xtractedFlds['X-Ham-Report']))) # WORKS
        # print(re.findall(emailRegEx, str(xtractedFlds['X-Ham-Report']))) # WORKS

        if body_emails is not None: # This list should be populated
            # Use list comprehension to filter out unwanted addresses and store the result in a new list
            filtered_addrs = [x for x in body_emails if x not in exclude_these]
            xtractedFlds['msgBody'] = filtered_addrs
        # print('Email addresses found in body: ' + str(filtered_addrs))

        if xtractedFlds['X-Ham-Report'] is not None:
            # Clean it so it's just email addresses
            addrs_only = re.findall(emailRegEx, str(xtractedFlds['X-Ham-Report']))

            # Now strip out email addresses you don't want in there
            filtered_addrs = [x for x in addrs_only if x not in exclude_these]

            # Now set it back to the original object
            xtractedFlds['X-Ham-Report'] = filtered_addrs

        if xtractedFlds['Final-Recipient'] is None:
            if xtractedFlds['X-Failed-Recipients'] is not None:
                xtractedFlds['Final-Recipient'] = xtractedFlds['X-Failed-Recipients']
            elif xtractedFlds['Original-Recipient'] is not None:
                xtractedFlds['Final-Recipient'] = xtractedFlds['Original-Recipient']
            elif xtractedFlds['From'] is not None:
                xtractedFlds['Final-Recipient'] = xtractedFlds['From']
            else: xtractedFlds['Final-Recipient'] = 'Final-Recipient@no.val'
        # problem_addr = msg['X-Failed-Recipients']
        # # If 'problem_addr' is still null, set it to the 
        # if problem_addr is None: # see https://realpython.com/python-string-contains-substring/
        #     if 'MAILER-DAEMON' in msg['From'] or 'postmaster' in msg['From']:
        #         problem_addr = msg['Original-Recipient']
        # # If 'problem_addr' is still null, try the 'Final-Recipient' field instead
        # if problem_addr is None:
        #     problem_addr = msg['Final-Recipient']
        # # If 'problem_addr' is STILL null, give up and set it to the first valid email address in the 'From' field
        # if problem_addr is None:
        #     problem_addr = re.findall(r'[\w\.-]+@[\w\.-]+', msg['From'])[0]
        
        # xtractedFlds['Final-Recipient'] = problem_addr
        # subject = msg['Subject']
        # auto_reply = msg['Auto-Submitted']
        # # print(msg['Subject'])
        # # print(msg['Final-Recipient']) 
        # # print (problem_addr, subject, auto_reply)
        # print (xtractedFlds)
        # return (problem_addr, subject, auto_reply)
        # print(xtractedFlds['Final-Recipient'])
        # return (xtractedFlds['Final-Recipient'], xtractedFlds['Subject'], xtractedFlds['Auto-Submitted'])
        return (xtractedFlds)
# END extract_info function ---------------------------------------------------------#

# Create an empty dictionary to store the information
info_dict = {}


# Define the folder path
# folder_path = 'ThunderbirdExports-TESTING'
myDir = path.abspath(path.dirname(__file__)) # mine
targetFolder = 'ThunderbirdExports-TESTING' # mine
folder_path = path.join(myDir, targetFolder) # mine
# emailRegEx = re.compile("[a-zA-Z0-9_\.\-\+]{1,}@[a-zA-Z0-9\-]+\.[a-zA-Z0-9]{2,4}") # using re.compile is faster if using the pattern repeatedly.
big_array = []
# Iterate over the .eml files in the folder
for eml_file in os.listdir(folder_path):
    # Check if the file is a .eml file
    if eml_file.endswith('.eml'):
        # print('File Name:  ', eml_file) # DEBUGGING
        # Create the full file path
        file_path = os.path.join(folder_path, eml_file)
        # Extract the relevant information from the file
        # emailAddr, subject, auto_reply = extract_info(file_path)
        emlData = extract_info(file_path)
        big_array.append(emlData)
        # print(type(emailAddr)) # print(str.format("Type is:  {type(emailAddr)}"))
        problem_addr = str(emlData['Final-Recipient'])
        cleaned_addr = re.findall(emailRegEx, problem_addr)[0]
        subject = emlData['Subject']
        thread_topic = emlData['Thread-Topic']
        auto_reply = emlData['Auto-Submitted']
        # problem_addr = re.findall(emailRegEx, emailAddr)[0]
        # Add the extracted information to the dictionary
        # If problem_addr already exists, update it
        if cleaned_addr in info_dict:
            info_dict[cleaned_addr]['frequency'] += 1
            if subject in info_dict[cleaned_addr]['subjects']:
                info_dict[cleaned_addr]['subjects'][subject] += 1
            elif subject is not None: info_dict[cleaned_addr]['subjects'][subject] = 1

            if thread_topic in info_dict[cleaned_addr]['subjects']:
                info_dict[cleaned_addr]['subjects'][thread_topic] += 1
            elif thread_topic is not None: info_dict[cleaned_addr]['subjects'][thread_topic] = 1
            # if auto_reply in info_dict[cleaned_addr]['auto_replies']:
            #     info_dict[cleaned_addr]['auto_replies'][auto_reply] += 1
            # else: info_dict[cleaned_addr]['auto_replies'][auto_reply] = 1
            
        # If problem_addr doesn't already exist, add it.
        else:
            info_dict[cleaned_addr] = {
                'frequency': 1, 
                'subjects': {subject: 1}, 
                # 'auto_replies': {auto_reply: 1},
                'X-Failed-Recipients': emlData['X-Failed-Recipients'],
                'Original-Recipient': emlData['Original-Recipient'],
                'From': re.findall(emailRegEx, emlData['From'])[0]

            }
# # DEPLOYMENT #
# # Convert the dictionary to JSON
# json_str = json.dumps(info_dict, indent=4)

# # Print the dictionary
# print(json_str)
# # END DEPLOYMENT

# DEVELOPMENT
# json_str = json.dumps(big_array, indent=4)
# filtered_big_array is the subset of big_array wherein the msgBody list isn't empty
#   A more efficient way than checking len(x['msgBody']) is to leverage the fact
#   that when a list is put in an if statement, it returns True if non-empty and false otherwise.
#   See https://datagy.io/check-if-python-list-is-empty/
filtered_big_array = [x for x in big_array if x['msgBody']]
json_str = json.dumps(filtered_big_array, indent=4)
print(json_str)
# END DEVELOPMENT
