# The following code was generated by ChatGPT Dec 15 Version (found at https://chat.openai.com/chat)
# ChatGPT gave the following explanation of the code:
#   This code defines a function extract_info() that takes a file path and returns the relevant information 
#   from the .eml file at that path. It then iterates over the .eml files in the specified folder and calls the 
#   extract_info() function on each file. The extracted information is added to the info_dict dictionary, where 
#   the keys are the email addresses and the values are dictionaries containing the error message, subject line, 
#   and whether the email is an automatic reply.

import email
import re
import json
import csv
import os 
from os import path # MINE
from collections import Counter
# import pdb # DEBUGGING
from datetime import datetime
# from dateutil import parser # Requires 3rd-party lib?

# Making this global. Will Probably move this to a config folder later.
emailRegEx = re.compile("[a-zA-Z0-9_\.\-\+]{1,}@[a-zA-Z0-9\-\.]+\.[a-zA-Z0-9]{2,4}") # using re.compile is faster if using the pattern repeatedly.
emailPartRegEx = re.compile("[a-zA-Z0-9_\.\-\+]{1,}@[a-zA-Z0-9\-\.]+")
emlDateFormat = '%a, %d %b %Y %H:%M:%S %z' # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior
threadTopicRegex = re.compile("Thread-Topic:\s([\w\s]+)")
def extract_email_list(text_block):
    # print("var 'text_block' is of type: " + str(type(text_block))) # DEBUGGING
    if type(text_block) is not str: text_block = str(text_block)    
    email_list = []
    try: email_list.extend(re.findall(emailRegEx, text_block))
    except: 
        print('Line 23 failed. Trying Line 26.')
        email_list.extend(re.findall(emailPartRegEx, text_block))
    
    # Final attempt to extract partial email address
    if not bool(email_list): email_list.extend(re.findall(emailPartRegEx, text_block))
    # print('length of email_list:  ' + str(len(email_list)))
    return email_list
# END extract_email_list()

# Define a function to extract the relevant information from a .eml file
def extract_info(file_path): # in the "open()" command, if encoding isn't specified, the operation can fail with a variety of coding errors
    # with open(file_path, 'r', encoding="UTF-8") as fileContents:
    #     msg = email.message_from_file(fileContents)
    with open(file_path, 'rb') as fileContents: # opening file in binary mode works for most cases where file encoding is harder to detect.
        msg = email.message_from_binary_file(fileContents)

        xtractedFlds = {}
        xtractedFlds['Problem-Address'] = None
        xtractedFlds['Delivery-Date'] = msg['Delivery-Date']
        # print(datetime.datetime.strptime(msg['Delivery-Date'], emlDateFormat))
        xtractedFlds['Delivered-To']= msg['Delivered-To']
        xtractedFlds['Subject']= msg['Subject']
        xtractedFlds['Thread-Topic']= msg['Thread-Topic']
        xtractedFlds['X-Failed-Recipients']= msg['X-Failed-Recipients']
        xtractedFlds['Original-Recipient']= msg['Original-Recipient']
        xtractedFlds['Final-Recipient']= msg['Final-Recipient']
        xtractedFlds['From']= msg['From']
        xtractedFlds['To']= msg['To']
        xtractedFlds['Auto-Submitted']= msg['Auto-Submitted']
        xtractedFlds['X-Ham-Report']= msg['X-Ham-Report']
        # xtractedFlds['X-Ham-Report']= re.findall(emailRegEx, str(msg['X-Ham-Report']))
        body_emails = None
        # Used for filtering out invalid results
        clientAddr = extract_email_list(xtractedFlds['Delivered-To'])[0] # str(re.search(emailRegEx, str(xtractedFlds['Delivered-To']))[0])
        exclude_these = [clientAddr] # Can be an array of things to remove
        for part in msg.walk():
            # print('msg part type: ' + str(part.get_content_type()))
            for key in xtractedFlds.keys():
                if xtractedFlds[key] is None:
                    # To avoid setting the val of a key to that of the client's email addr
                    if clientAddr not in str(part[key]): 
                        xtractedFlds[key] = part[key]
            if part.get_content_type() == "text/plain":
                body = part.get_payload(decode=True)
                # Body has been extracted
                body_decoded = body.decode()
                # Extract all valid emails from body
                body_emails = extract_email_list(body_decoded) #body_emails = re.findall(emailRegEx, body_decoded)
            if part.get_content_type() == "text/rfc822-headers" and xtractedFlds['Thread-Topic'] is None:
                body = part.get_payload(decode=True)
                # Body has been extracted
                body_decoded = body.decode()
                # print('Thread-Topic by Regex: '+str(re.search(threadTopicRegex, str(body)).group(1)))
                xtractedFlds['Thread-Topic'] = str(re.search(threadTopicRegex, str(body)).group(1)).strip()
                # if body_emails is None: re.findall(emailPartRegEx, body_decoded)
        # print(xtractedFlds['X-Ham-Report']) # WORKS
        # print(re.findall(r'[\w\.-]+@[\w\.-]+', str(xtractedFlds['X-Ham-Report']))) # WORKS
        # print(re.findall(emailRegEx, str(xtractedFlds['X-Ham-Report']))) # WORKS
#       print('\nThread Topic Type: '+str(type(xtractedFlds['Thread-Topic'])))
        # CONVERT THE EML-FORMAT DATE STRING TO A DATE OBJECT, THEN TO AN ISO DATE STRING
        # IF IT ISN'T EXPLICITYLY CONVERTED TO A DATE STRING, IT WILL FAIL TO CONVERT TO A JSON STRING LATER
        xtractedFlds['Delivery-Date']= datetime.strptime(str(xtractedFlds['Delivery-Date']), emlDateFormat).strftime('%Y-%m-%dT%H:%M:%S%z')
        
        # print(str(body_emails))
        if body_emails is not None: # This list should be populated
            # Use list comprehension to filter out unwanted addresses and store the result in a new list
            filtered_addrs = [x for x in body_emails if x not in exclude_these]
            # print(str(filtered_addrs))
            xtractedFlds['msgBody'] = filtered_addrs
        else: xtractedFlds['msgBody'] = None
        # print('Email addresses found in body: ' + str(filtered_addrs))

        if xtractedFlds['X-Ham-Report'] is not None:
            # Clean it so it's just email addresses
            addrs_only = extract_email_list(xtractedFlds['X-Ham-Report']) # addrs_only = re.findall(emailRegEx, str(xtractedFlds['X-Ham-Report']))

            # Now strip out email addresses you don't want in there
            filtered_addrs = [x for x in addrs_only if x not in exclude_these]

            # Now set it back to the original object
            xtractedFlds['X-Ham-Report'] = filtered_addrs

        # Attempt to identify the problem address and create a key value pair for it
        xtractedFlds['Problem-Address'] = extract_email_list(xtractedFlds['Final-Recipient'])
        if len(xtractedFlds['Problem-Address']) < 1: xtractedFlds['Problem-Address'] = None # sets back to none of len is 0
        if xtractedFlds['Problem-Address'] is None:
            if bool(xtractedFlds['X-Failed-Recipients']): # if xtractedFlds['X-Failed-Recipients'] is not None and len(xtractedFlds['X-Failed-Recipients']) > 0:
                xtractedFlds['Problem-Address'] = xtractedFlds['X-Failed-Recipients'] # re.findall(emailRegEx, (xtractedFlds['X-Failed-Recipients']))
            elif bool(xtractedFlds['Original-Recipient']): # elif xtractedFlds['Original-Recipient'] is not None:
                xtractedFlds['Problem-Address'] = xtractedFlds['Original-Recipient'] # re.findall(emailRegEx, (xtractedFlds['Original-Recipient']))
            elif bool(xtractedFlds['From']): # elif xtractedFlds['From'] is not None:
                xtractedFlds['Problem-Address'] = xtractedFlds['From'] # re.findall(emailRegEx, (xtractedFlds['From']))
            else: xtractedFlds['Problem-Address'] = clientAddr
        
        # Now do a final check to ensure that the client address isn't marked as the problem
        if clientAddr or 'MAILER-DAEMON' or 'postmaster' in xtractedFlds['Problem-Address']:
            # print(f"xtractedFlds['msgBody'] bool val: {bool(xtractedFlds['msgBody'])}") # DEBUGGING
            if xtractedFlds['msgBody']: 
                # print(xtractedFlds['msgBody'][0]) # DEBUGGING
                xtractedFlds['Problem-Address'] = xtractedFlds['msgBody'][0]

        # Now do a final cleaning of the problem addr to ensure it doesn't contain invalid items
        # print("xtractedFlds['Problem-Address'] is of type: " + str(type(xtractedFlds['Problem-Address'])) + '    with a val of: ' + str(xtractedFlds['Problem-Address'])) # DEBUGGING
        try: xtractedFlds['Problem-Address'] = extract_email_list(xtractedFlds['Problem-Address'])[0] # try: xtractedFlds['Problem-Address'] = re.findall(emailRegEx, str(xtractedFlds['Problem-Address']))[0]
        except: 
            print(json.dumps(xtractedFlds, indent=4))
            xtractedFlds['Problem-Address'] = re.sub("[\"\'\[\]]","",xtractedFlds['Problem-Address'])
            # pdb.set_trace() # DEBUGGING to halt execution
            
        # print(json.dumps(xtractedFlds,indent=2)) # DEBUGGING 
        # except: xtractedFlds['Problem-Address'] = re.findall(emailPartRegEx, str(xtractedFlds['Problem-Address']))[0]
        # if problem_addr is None: # see https://realpython.com/python-string-contains-substring/
        #     if 'MAILER-DAEMON' in msg['From'] or 'postmaster' in msg['From']:
        #         problem_addr = msg['Original-Recipient']
        # # If 'problem_addr' is still null, try the 'Final-Recipient' field instead
        # if problem_addr is None:
        #     problem_addr = msg['Final-Recipient']
        # # If 'problem_addr' is STILL null, give up and set it to the first valid email address in the 'From' field
        # if problem_addr is None:
        #     problem_addr = re.findall(r'[\w\.-]+@[\w\.-]+', msg['From'])[0]
        
        # xtractedFlds['Final-Recipient'] = problem_addr
        # subject = msg['Subject']
        # auto_reply = msg['Auto-Submitted']
        # # print(msg['Subject'])
        # # print(msg['Final-Recipient']) 
        # # print (problem_addr, subject, auto_reply)
        # print (xtractedFlds)
        # return (problem_addr, subject, auto_reply)
        # print(xtractedFlds['Final-Recipient'])
        # return (xtractedFlds['Final-Recipient'], xtractedFlds['Subject'], xtractedFlds['Auto-Submitted'])
        return (xtractedFlds)
# END extract_info function ---------------------------------------------------------#

# Create an empty dictionary to store the information
info_dict = {}


# Define the folder path
myDir = path.abspath(path.dirname(__file__)) # mine
# targetFolder = 'ThunderbirdExports-TESTING' # DEBUGGING
targetFolder = 'ThunderbirdExports' # DEPLOYMENT
folder_path = path.join(myDir, targetFolder) # mine
# print("val of 'folder_path' in main:  " + folder_path) # emailRegEx = re.compile("[a-zA-Z0-9_\.\-\+]{1,}@[a-zA-Z0-9\-]+\.[a-zA-Z0-9]{2,4}") # using re.compile is faster if using the pattern repeatedly.
big_array = []
error_list = []
# Iterate over the .eml files in the folder
for eml_file in os.listdir(folder_path):
    # Check if the file is a .eml file
    if eml_file.endswith('.eml'):
        # print('File Name:  ', eml_file) # DEBUGGING
        # Create the full file path
        file_path = os.path.join(folder_path, eml_file)
        # Extract the relevant information from the file
        # emailAddr, subject, auto_reply = extract_info(file_path)
        try: emlData = extract_info(file_path)
        except: 
            print('FAILURE ON: extract_info(file_path)!!!')
            error_list.append(eml_file)

        big_array.append(emlData)
        # print(type(emailAddr)) # print(str.format("Type is:  {type(emailAddr)}"))
        problem_addr = str(emlData['Problem-Address'])
        cleaned_addr = problem_addr #re.findall(emailRegEx, problem_addr)[0]
        subject = emlData['Subject']
        thread_topic = emlData['Thread-Topic']
        auto_reply = emlData['Auto-Submitted']
        # problem_addr = re.findall(emailRegEx, emailAddr)[0]
        # Add the extracted information to the dictionary
        # If problem_addr already exists, update it
        if cleaned_addr in info_dict:
            info_dict[cleaned_addr]['frequency'] += 1
            # if subject in info_dict[cleaned_addr]['subjects']:
            #     info_dict[cleaned_addr]['subjects'][subject] += 1
            # elif subject is not None: info_dict[cleaned_addr]['subjects'][subject] = 1
            if thread_topic is not None:
                if thread_topic in info_dict[cleaned_addr]['subjects']:
                    info_dict[cleaned_addr]['subjects'][thread_topic] += 1
                else: info_dict[cleaned_addr]['subjects'][thread_topic] = 1
            elif subject is not None:
                # print('Thread_topic is None. Falling back to subject: ' + str(subject))
                if subject in info_dict[cleaned_addr]['subjects']:
                    info_dict[cleaned_addr]['subjects'][subject] += 1
                else: info_dict[cleaned_addr]['subjects'][subject] = 1
            # if auto_reply in info_dict[cleaned_addr]['auto_replies']:
            #     info_dict[cleaned_addr]['auto_replies'][auto_reply] += 1
            # else: info_dict[cleaned_addr]['auto_replies'][auto_reply] = 1
            if info_dict[cleaned_addr]['newest'] < emlData['Delivery-Date']:
                info_dict[cleaned_addr]['newest'] = emlData['Delivery-Date']
            if info_dict[cleaned_addr]['oldest'] > emlData['Delivery-Date']:
                info_dict[cleaned_addr]['oldest'] = emlData['Delivery-Date']
            
        # If problem_addr doesn't already exist, add it.
        else:
            info_dict[cleaned_addr] = {
                'frequency': 1, 
                'newest': emlData['Delivery-Date'],
                'oldest': emlData['Delivery-Date'],
                'subjects': {}, # 'subjects': {subject: 1}, 
                # 'auto_replies': {auto_reply: 1},
                'X-Failed-Recipients': emlData['X-Failed-Recipients'],
                'Original-Recipient': emlData['Original-Recipient'],
                'From': re.findall(emailRegEx, emlData['From'])[0]
            }
            if thread_topic is not None:
                info_dict[cleaned_addr]['subjects'][thread_topic] = 1
            elif subject is not None:
                info_dict[cleaned_addr]['subjects'][subject] = 1

# # DEPLOYMENT #
# # Convert the dictionary to JSON
# json_str = json.dumps(info_dict, indent=4)

# # Print the dictionary
# print(json_str)
# # END DEPLOYMENT

# DEVELOPMENT
# json_str = json.dumps(big_array, indent=4)
# # filtered_big_array is the subset of big_array wherein the msgBody list isn't empty
# #   A more efficient way than checking len(x['msgBody']) is to leverage the fact
# #   that when a list is put in an if statement, it returns True if non-empty and false otherwise.
# #   See https://datagy.io/check-if-python-list-is-empty/
# filtered_big_array = [x for x in big_array if x['msgBody']]
# json_str = json.dumps(filtered_big_array, indent=4)
# print(json_str)
# END DEVELOPMENT

# SORT SUMMARY DICTIONARY BY FREQUENCY
# https://www.geeksforgeeks.org/python-sort-nested-dictionary-by-key/
# https://www.geeksforgeeks.org/python-sorted-function/
# https://www.geeksforgeeks.org/python-lambda-anonymous-functions-filter-map-reduce/
# print('Summary dictionary in sorted form:') #DEBUGGING
# sortedSummary = sorted(info_dict.items(), key = lambda x: x[1]['frequency'], reverse=True)
sortedSummary = sorted(info_dict.items(), key = lambda x: (x[1]['frequency'], x[1]['newest']), reverse=True)
# sortedSummary = sorted(info_dict.items(), key=lambda x: (x[1]['frequency'], x[1]['newest']), reverse=True)
# print(json.dumps(sortedSummary, indent=4)) # DEBUGGING
# END SORT SUMMARY DICTIONARY BY FREQUENCY


#-----------------------------------------------------------------------------------#
# SAVE THE JSON ARRAY TO FILE
output_filename = 'EmlAnalysis.json'
# open in write-mode will create a file if it doesn't exist and overwrite it if it does.
with open(output_filename, mode='w') as target_file:
    # target_file.write(json_str)
    # USE json.dump() to handle encoding
    # json.dump(obj=filtered_big_array, indent=4, fp=target_file)
    json.dump(obj=big_array, indent=4, fp=target_file)
target_file.close
print(f"'{output_filename}' completed. Contains {len(big_array)} entries.")
# END SAVE JSON ARRAY TO FILE

# SAVE SUMMARY OBJ TO JSON FILE
output_filename = 'EmlAnalysis_SUMMARY.json'
# open in write-mode will create a file if it doesn't exist and overwrite it if it does.
with open(output_filename, mode='w') as target_file:
    # target_file.write(json_str)
    # USE json.dump() to handle encoding
    # json.dump(obj=info_dict, indent=4, fp=target_file) # unsorted dictionary, but correct JSON formatting
    json.dump(obj=sortedSummary, indent=4, fp=target_file) # sorted correctly, but incorrect JSON formatting
target_file.close
print(f"'{output_filename}' completed. Contains {len(info_dict)} entries.")
# END SAVE SUMMARY OBJ TO JSON FILE

# SAVE FULL JSON ARRAY TO CSV
output_filename = 'EmlAnalysis.csv'
field_names = big_array[0].keys()
# print(field_names)
with open(os.path.join(myDir, output_filename), mode='w', newline='') as target_file:
    # writer = csv.DictWriter(file=os.path.join(folder_path, output_filename), fieldnames=field_names)
    writer = csv.DictWriter(f=target_file, fieldnames=field_names)
    writer.writeheader()
    writer.writerows(big_array)
target_file.close
# END SAVE FULL JSON ARRAY TO CSV

# SAVE SUMMARY OBJ TO JSON FILE
output_filename = 'ERROR_LOG.txt'
# open in write-mode will create a file if it doesn't exist and overwrite it if it does.
with open(output_filename, mode='w') as target_file:
    error_list = {"errors":error_list}
    # USE json.dump() to handle encoding
    json.dump(obj=error_list, indent=2, fp=target_file)
target_file.close
print(f"'{output_filename}' completed. Contains {len(error_list['errors'])} entries.")
print('ERRORS: ')
print("    " + str(error_list['errors']))
# END SAVE SUMMARY OBJ TO JSON FILE
#-----------------------------------------------------------------------------------#

# #-----------------------------------------------------------------------------------#
# #---------------- TESTING DATE STRING FORMATTING -----------------------------------#
# # emlDateFormat = '%a, %d %b %Y %H:%M:%S %z'
# dateStr = 'Wed, 01 Jun 2022 14:03:24 -0400'
# # print(datetime.datetime.strptime(dateStr, emlDateFormat)) # if import datetime
# dtObj = datetime.strptime(dateStr, emlDateFormat)
# iso_str = dtObj.strftime('%Y-%m-%dT%H:%M:%S%z')
# # print(datetime.strptime(dateStr, emlDateFormat)) # if from datetime import datetime
# print(dtObj)
# print(iso_str)
# #----------------- END TESTING DATE STRING FORMATTING ------------------------------#
# #-----------------------------------------------------------------------------------#