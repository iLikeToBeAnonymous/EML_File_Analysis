# The following code was generated by ChatGPT Dec 15 Version (found at https://chat.openai.com/chat)
# ChatGPT gave the following explanation of the code:
#   This code defines a function extract_info() that takes a file path and returns the relevant information 
#   from the .eml file at that path. It then iterates over the .eml files in the specified folder and calls the 
#   extract_info() function on each file. The extracted information is added to the info_dict dictionary, where 
#   the keys are the email addresses and the values are dictionaries containing the error message, subject line, 
#   and whether the email is an automatic reply.

import email
import re
import json
import os 
from os import path # MINE
from collections import Counter

# Define a function to extract the relevant information from a .eml file
def extract_info(file_path):
    with open(file_path, 'r') as fileContents:
        msg = email.message_from_file(fileContents)

        xtractedFlds = {}
        xtractedFlds['Delivered-To']= msg['Delivered-To']
        xtractedFlds['Subject']= msg['Subject']
        xtractedFlds['Thread-Topic']= msg['Thread-Topic']
        xtractedFlds['X-Failed-Recipients']= msg['X-Failed-Recipients']
        xtractedFlds['Original-Recipient']= msg['Original-Recipient']
        xtractedFlds['Final-Recipient']= msg['Final-Recipient']
        xtractedFlds['From']= msg['From']
        xtractedFlds['To']= msg['To']
        xtractedFlds['Auto-Submitted']= msg['Auto-Submitted']
        
        # Used for filtering out invalid results
        clientAddr = xtractedFlds['Delivered-To']

        for part in msg.walk():
            for key in xtractedFlds.keys():
                if xtractedFlds[key] is None:
                    # To avoid setting the val of a key to that of the client's email addr
                    if clientAddr not in str(part[key]): 
                        xtractedFlds[key] = part[key]

        if xtractedFlds['Final-Recipient'] is None:
            if xtractedFlds['X-Failed-Recipients'] is not None:
                xtractedFlds['Final-Recipient'] = xtractedFlds['X-Failed-Recipients']
            elif xtractedFlds['Original-Recipient'] is not None:
                xtractedFlds['Final-Recipient'] = xtractedFlds['Original-Recipient']
            elif xtractedFlds['From'] is not None:
                xtractedFlds['Final-Recipient'] = xtractedFlds['From']
            else: xtractedFlds['Final-Recipient'] = 'Final-Recipient@no.val'
        # problem_addr = msg['X-Failed-Recipients']
        # # If 'problem_addr' is still null, set it to the 
        # if problem_addr is None: # see https://realpython.com/python-string-contains-substring/
        #     if 'MAILER-DAEMON' in msg['From'] or 'postmaster' in msg['From']:
        #         problem_addr = msg['Original-Recipient']
        # # If 'problem_addr' is still null, try the 'Final-Recipient' field instead
        # if problem_addr is None:
        #     problem_addr = msg['Final-Recipient']
        # # If 'problem_addr' is STILL null, give up and set it to the first valid email address in the 'From' field
        # if problem_addr is None:
        #     problem_addr = re.findall(r'[\w\.-]+@[\w\.-]+', msg['From'])[0]
        
        # xtractedFlds['Final-Recipient'] = problem_addr
        # subject = msg['Subject']
        # auto_reply = msg['Auto-Submitted']
        # # print(msg['Subject'])
        # # print(msg['Final-Recipient']) 
        # # print (problem_addr, subject, auto_reply)
        # print (xtractedFlds)
        # return (problem_addr, subject, auto_reply)
        # print(xtractedFlds['Final-Recipient'])
        # return (xtractedFlds['Final-Recipient'], xtractedFlds['Subject'], xtractedFlds['Auto-Submitted'])
        return (xtractedFlds)
# END extract_info function ---------------------------------------------------------#

# Create an empty dictionary to store the information
info_dict = {}


# Define the folder path
# folder_path = 'ThunderbirdExports-TESTING'
myDir = path.abspath(path.dirname(__file__)) # mine
targetFolder = 'ThunderbirdExports-TESTING' # mine
folder_path = path.join(myDir, targetFolder) # mine
emailRegEx = re.compile("[a-zA-Z0-9_\.\-\+]{1,}@[a-zA-Z0-9\-]+\.[a-zA-Z0-9]{2,4}") # using re.compile is faster if using the pattern repeatedly.

# Iterate over the .eml files in the folder
for eml_file in os.listdir(folder_path):
    # Check if the file is a .eml file
    if eml_file.endswith('.eml'):
        # print('File Name:  ', eml_file) # DEBUGGING
        # Create the full file path
        file_path = os.path.join(folder_path, eml_file)
        # Extract the relevant information from the file
        # emailAddr, subject, auto_reply = extract_info(file_path)
        emlData = extract_info(file_path)
        # print(type(emailAddr)) # print(str.format("Type is:  {type(emailAddr)}"))
        problem_addr = str(emlData['Final-Recipient'])
        cleaned_addr = re.findall(r'[\w\.-]+@[\w\.-]+', problem_addr)[0]
        subject = emlData['Subject']
        thread_topic = emlData['Thread-Topic']
        auto_reply = emlData['Auto-Submitted']
        # problem_addr = re.findall(emailRegEx, emailAddr)[0]
        # Add the extracted information to the dictionary
        # If problem_addr already exists, update it
        if cleaned_addr in info_dict:
            info_dict[cleaned_addr]['frequency'] += 1
            if subject in info_dict[cleaned_addr]['subjects']:
                info_dict[cleaned_addr]['subjects'][subject] += 1
            else: info_dict[cleaned_addr]['subjects'][subject] = 1

            if thread_topic in info_dict[cleaned_addr]['subjects']:
                info_dict[cleaned_addr]['subjects'][thread_topic] += 1
            else: info_dict[cleaned_addr]['subjects'][thread_topic] = 1
            # if auto_reply in info_dict[cleaned_addr]['auto_replies']:
            #     info_dict[cleaned_addr]['auto_replies'][auto_reply] += 1
            # else: info_dict[cleaned_addr]['auto_replies'][auto_reply] = 1
            
        # If problem_addr doesn't already exist, add it.
        else:
            info_dict[cleaned_addr] = {
                'frequency': 1, 
                'subjects': {subject: 1}, 
                # 'auto_replies': {auto_reply: 1},
                'X-Failed-Recipients': emlData['X-Failed-Recipients'],
                'Original-Recipient': emlData['Original-Recipient'],
                'From': re.findall(emailRegEx, emlData['From'])[0]

            }

# Convert the dictionary to JSON
json_str = json.dumps(info_dict, indent=4)

# Print the dictionary
print(json_str)